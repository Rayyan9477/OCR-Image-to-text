import streamlit as st
from PIL import Image
import io
import importlib
import base64
import os
import time
import sys
import subprocess

# Initialize session state for error tracking
if 'dependency_errors' not in st.session_state:
    st.session_state['dependency_errors'] = []

# Set environment variables to suppress TensorFlow warnings
# and fix the Keras 3 compatibility issue
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'
os.environ['TF_USE_LEGACY_KERAS'] = '1'
os.environ['KERAS_BACKEND'] = 'tensorflow'

# Try to fix the Keras version issue before loading other modules
try:
    # Check if keras is available
    if importlib.util.find_spec('keras'):
        import keras
        keras_version = keras.__version__
        if keras_version.startswith('3.'):
            st.info("Note: Using compatibility mode for Keras 3")
            st.session_state['dependency_errors'].append(
                "Using Keras 3 compatibility mode. Some advanced features may be limited."
            )
    
    # Check for tf_keras as an alternative
    elif importlib.util.find_spec('tf_keras'):
        import tf_keras
        st.info("Using tf-keras for compatibility")
        
    # Check if no keras available
    else:
        st.warning("Keras not found - Q&A features will be limited")
        st.session_state['dependency_errors'].append(
            "Keras not available - Q&A features will be limited"
        )
except Exception as e:
    # Just log the error, don't try to fix it
    st.session_state['dependency_errors'].append(f"Keras compatibility note: {str(e)}")
    pass

# Now import our modules
from model_manager import initialize_models, get_ocr_config, update_ocr_config
from ocr_module import perform_ocr, detect_tables, detect_image_quality
from rag_module import process_query

# Dynamic import for fitz (PyMuPDF)
try:
    fitz = importlib.import_module('fitz')  # PyMuPDF
except ImportError:
    st.error("PyMuPDF not installed. Install with 'pip install pymupdf'")
    fitz = None

def load_css():
    css_file = os.path.join(os.path.dirname(__file__), 'static', 'styles.css')
    try:
        with open(css_file, encoding='utf-8') as f:
            st.markdown(f'<style>{f.read()}</style>', unsafe_allow_html=True)
    except UnicodeDecodeError:
        # Provide basic fallback CSS if there's an encoding issue
        fallback_css = """
        .formatted-text {
            position: relative;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 1rem;
            max-height: 500px;
            overflow-y: auto;
            font-family: monospace;
            white-space: pre-wrap;
            margin-bottom: 1rem;
        }
        
        .copy-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: rgba(0, 123, 255, 0.1);
            border: none;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
        }
        """
        st.markdown(f'<style>{fallback_css}</style>', unsafe_allow_html=True)

def load_js():
    js_file = os.path.join(os.path.dirname(__file__), 'static', 'script.js')
    try:
        with open(js_file, encoding='utf-8') as f:
            js_content = f.read()
    except UnicodeDecodeError:
        # Fallback to another encoding or use a hardcoded version of the script
        js_content = """
        // Fallback script
        function copyText(button) {
            const textContainer = button.parentElement.querySelector('pre');
            if (!textContainer) {
                console.error('Text container not found');
                button.innerHTML = '‚ùå';
                setTimeout(() => button.innerHTML = 'üìã', 2000);
                return;
            }
            
            const text = textContainer.innerText || textContainer.textContent;
            
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(text)
                    .then(() => {
                        button.innerHTML = '‚úì';
                        setTimeout(() => button.innerHTML = 'üìã', 2000);
                    })
                    .catch(err => {
                        console.error('Failed to copy:', err);
                    });
            } else {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.opacity = '0';
                document.body.appendChild(textArea);
                
                try {
                    textArea.select();
                    document.execCommand('copy');
                    button.innerHTML = '‚úì';
                    setTimeout(() => button.innerHTML = 'üìã', 2000);
                } catch (err) {
                    console.error('Fallback copy failed:', err);
                    button.innerHTML = '‚ùå';
                    setTimeout(() => button.innerHTML = 'üìã', 2000);
                } finally {
                    document.body.removeChild(textArea);
                }
            }
        }
        """
    
    # Inject the JavaScript using components.html
    js_code = f"""
    <script>
    {js_content}
    
    // Initialize at document load to ensure script is loaded properly
    document.addEventListener('DOMContentLoaded', function() {{
        // Attach click handlers to any copy buttons that exist
        const copyButtons = document.querySelectorAll('.copy-btn');
        copyButtons.forEach(btn => {{
            btn.addEventListener('click', function() {{
                copyText(this);
            }});
        }});
    }});
    
    // Re-attach event listeners when Streamlit reruns
    const observer = new MutationObserver(function(mutations) {{
        const copyButtons = document.querySelectorAll('.copy-btn');
        copyButtons.forEach(btn => {{
            if (!btn.hasAttribute('data-listener')) {{
                btn.setAttribute('data-listener', 'true');
                btn.addEventListener('click', function() {{
                    copyText(this);
                }});
            }}
        }});
    }});
    
    // Start observing the document with the configured parameters
    observer.observe(document.body, {{ childList: true, subtree: true }});
    </script>
    """
    st.components.v1.html(js_code, height=0)

def main():
    try:
        load_css()
    except Exception as e:
        st.warning(f"Could not load custom styles: {str(e)}. Using default styles.")
    
    try:
        load_js()
    except Exception as e:
        st.warning(f"Could not load JavaScript functions: {str(e)}. Some interactive features may be limited.")

    if 'extracted_text' not in st.session_state:
        st.session_state['extracted_text'] = ''
        
    # Initialize models with progress indicator
    if 'models_initialized' not in st.session_state:
        with st.spinner('Initializing OCR models...'):
            try:
                initialize_models()
                st.session_state['models_initialized'] = True
            except Exception as e:
                st.error(f"Error initializing models: {str(e)}")
                st.info("The app will continue with limited functionality.")

    st.markdown("""
        <div class="header">
            <h1>Intelligent OCR and Text Analysis Tool</h1>
            <p>Developed by <strong>Rayyan Ahmed</strong></p>
            <p>
                <a href="https://www.linkedin.com/in/rayyan-ahmed9477/" target="_blank">LinkedIn</a> |
                <a href="https://github.com/Rayyan9477/" target="_blank">GitHub</a> |
                Email: <a href="mailto:rayyanahmed265@yahoo.com">rayyanahmed265@yahoo.com</a>
            </p>
        </div>
    """, unsafe_allow_html=True)

    tabs = st.tabs(["üìÑ Document Processing", "‚öôÔ∏è OCR Settings", "‚ùì Q&A Interface"])

    # OCR settings in session state
    if 'ocr_engine' not in st.session_state:
        st.session_state['ocr_engine'] = 'combined'
    if 'preserve_layout' not in st.session_state:
        st.session_state['preserve_layout'] = True

    with tabs[0]:  # Document Processing Tab
        col1, col2 = st.columns(2)

        with col1:
            st.markdown("### Upload Document")
            uploaded_file = st.file_uploader(
                "Choose an image or PDF file",
                type=["jpg", "jpeg", "png", "pdf"],
                help="Supported formats: JPG, PNG, PDF"
            )
            if uploaded_file:
                if uploaded_file.type.startswith('image'):
                    image = Image.open(uploaded_file)
                    st.image(image, caption="Uploaded Image", use_column_width=True)
                    
                    # Check if image contains tables
                    has_tables = detect_tables(image)
                    if has_tables:
                        st.info("üìä Table structures detected in the image. Layout preservation is recommended.")
                    
                    with st.spinner('üîç Performing OCR...'):
                        extracted_text = perform_ocr(
                            image, 
                            engine=st.session_state['ocr_engine'], 
                            preserve_layout=st.session_state['preserve_layout']
                        )
                elif uploaded_file.type == 'application/pdf':
                    with st.spinner('üîç Performing OCR on PDF...'):
                        pdf_data = uploaded_file.read()
                        doc = fitz.open(stream=pdf_data, filetype="pdf")
                        extracted_text = ""
                        total_pages = len(doc)
                        
                        # Add a progress bar for PDF processing
                        progress_bar = st.progress(0)
                        
                        for i, page in enumerate(doc):
                            pix = page.get_pixmap()
                            img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
                            page_text = perform_ocr(
                                img, 
                                engine=st.session_state['ocr_engine'],
                                preserve_layout=st.session_state['preserve_layout']
                            )
                            extracted_text += f"--- PAGE {i+1} ---\n{page_text}\n\n"
                            progress_bar.progress((i + 1) / total_pages)
                else:
                    st.error("Unsupported file type!")
                    return
                st.session_state['extracted_text'] = extracted_text

        with col2:
            if st.session_state['extracted_text']:
                st.markdown("### Extracted Text")
                
                # Add options for displaying the text
                view_format = st.radio(
                    "View format", 
                    options=["Formatted", "Plain text"],
                    horizontal=True
                )
                  # Display the text based on the selected format
                if view_format == "Formatted":
                    # Generate a unique ID for this text block
                    text_id = f"output-text-{hash(st.session_state['extracted_text'])}"
                    
                    st.markdown(f"""
                        <div class="formatted-text">
                            <pre id="{text_id}" style="white-space: pre-wrap;">{st.session_state['extracted_text']}</pre>
                            <button class="copy-btn" onclick="copyText(this)" aria-label="Copy text">üìã</button>
                        </div>
                        <script>
                        // Ensure the button works immediately
                        document.querySelectorAll('.copy-btn').forEach(function(btn) {{
                            btn.addEventListener('click', function() {{
                                copyText(this);
                            }});
                        }});
                        </script>
                    """, unsafe_allow_html=True)
                else:
                    st.text_area("Plain text", st.session_state['extracted_text'], height=400)
                
                # Add file format options for download
                file_format = st.selectbox(
                    "Download format",
                    options=["TXT", "JSON", "Markdown"],
                    index=0
                )
                
                if file_format == "TXT":
                    download_data = st.session_state['extracted_text']
                    file_name = "extracted_text.txt"
                elif file_format == "JSON":
                    import json
                    download_data = json.dumps({"text": st.session_state['extracted_text']})
                    file_name = "extracted_text.json"
                else:  # Markdown
                    download_data = f"# Extracted Text\n\n```\n{st.session_state['extracted_text']}\n```"
                    file_name = "extracted_text.md"
                
                st.download_button(
                    "üíæ Download Text",
                    download_data,
                    file_name=file_name,
                    help=f"Download the extracted text as a {file_format} file"
                )
    
    with tabs[1]:  # OCR Settings Tab
        st.markdown("### OCR Engine Settings")
        
        # OCR engine selection
        engine = st.radio(
            "Select OCR Engine",
            options=["PaddleOCR (Recommended)", "EasyOCR", "Combined (Best results)"],
            index=2,
            horizontal=True
        )
        
        # Map UI options to engine parameter values
        engine_map = {
            "PaddleOCR (Recommended)": "paddle",
            "EasyOCR": "easy",
            "Combined (Best results)": "combined"
        }
        
        st.session_state['ocr_engine'] = engine_map[engine]
        
        # Layout preservation option
        st.session_state['preserve_layout'] = st.checkbox(
            "Preserve text layout and formatting",
            value=True,
            help="Maintains the original document's layout including line breaks and approximate text positioning"
        )
        
        # Add more OCR settings
        st.markdown("### Advanced Settings")
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("#### Image Preprocessing")
            apply_preprocessing = st.checkbox(
                "Enable image preprocessing",
                value=True,
                help="Applies various image enhancement techniques before OCR"
            )
        
        with col2:
            st.markdown("#### Language Settings")
            language = st.selectbox(
                "Language",
                options=["English", "Multi-language (Slower)"],
                index=0,
                help="Select the primary language of your document"
            )
            
        st.markdown("---")
        st.markdown("""
        ### OCR Engine Comparison
        - **PaddleOCR**: Fast and accurate, optimized for Asian languages but works well for English.
        - **EasyOCR**: Good general-purpose OCR with support for 80+ languages.
        - **Combined**: Uses both engines and selects the best result (recommended but slower).
        """)

    with tabs[2]:  # Q&A Interface Tab
        if 'extracted_text' in st.session_state and st.session_state['extracted_text']:
            st.markdown("### Ask Questions")
            query = st.text_input("Enter your question about the document")
            if query:
                with st.spinner('ü§î Finding answer...'):
                    result = process_query(st.session_state['extracted_text'], query)
                st.markdown(f"**Answer:** {result['answer']}")
                
                # Show confidence score
                confidence = result.get('confidence', 0) * 100
                st.progress(min(confidence / 100, 1.0))
                st.caption(f"Confidence: {confidence:.1f}%")
        else:
            st.info("Please upload and process a document first.")

if __name__ == '__main__':
    main()
